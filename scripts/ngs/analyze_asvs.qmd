---
title: "analyze_asvs"
format: html
---

Load all packages required for this script

```{r}
library(tidyverse)
library(gtools)
library(RColorBrewer)
library(forcats)
library(DECIPHER) 
library(Biostrings)   
library(tidyverse)
library(forcats)
library(Polychrome)
library(progress)
library(glue)
library(scales)
library(stringr)
library(colorspace)
```

Load the generated ASV files

```{r}
#| label: Load saved data
#| include: false
process_sample <- "none" #phe, nap, none
folder_path = paste0("../../results/ngs/", process_sample, "/")

asv_counts <- read.csv(paste0(folder_path, "ASV_counts_ids_", process_sample, ".csv"), header = TRUE)
asv_counts <- asv_counts %>% 
  tibble::column_to_rownames("X")
asv_map <- read.csv(paste0(folder_path, "ASV_id_sequence_map_", process_sample, ".csv"), header = TRUE)

```

Compute distance between ASVs. Needleman-W alignment of ASVs and displays a heatmap.

```{r}
#| label: Plot Heatmap of similarities of asvs

asv_seqs <- asv_map %>%
  distinct(ASV_ID, Sequence)
    
# Build a DNAStringSet with one entry per ASV
seq_set <- DNAStringSet(asv_seqs$Sequence)
names(seq_set) <- asv_seqs$ASV           # preserve ASV IDs

## Pairwise distances, global alignment (proportion mismatches, 0–1)
asv_dm <- DistanceMatrix(seq_set, type = "dist", verbose = FALSE)  # fast C implementation

pid_mat <- (1 - as.matrix(asv_dm)) * 100

heatmap(pid_mat, 
        symm=TRUE, 
        main="ASV Sequence Similarity",
        xlab="ASV", ylab="ASV")
```

Get the richness, evenness for each sample.

```{r}
#| label: Get richness and evenness
#| echo: false
# Calculate evenness for each sample using 
evennessFun <- function(sampleIn) {
  totalCounts <- sum(sampleIn)
  # Relative abundance
  p <- sampleIn / totalCounts
  # If we have p == 0 in some place
  H <- -sum(p[p > 0] * log(p[p > 0]))
  return(H)
}

# Run both richness and evenness at the same time
calcRichEven <- function() {
  richnesses <- numeric(length=nrow(asv_counts))
  evennesses <- numeric(length=nrow(asv_counts))
  for (i in 1:nrow(asv_counts)) {
    counts.sample <- as.integer(asv_counts[i, ])
    
    evenness.sample <- evennessFun(counts.sample)
    richnesses[i] <- sum(counts.sample > 0)
    evennesses[i] <- evenness.sample
  }
  return(data.frame(richnesses, evennesses))
}

richEven <- calcRichEven()
rownames(richEven) <- gsub("_F_filt.fastq.gz$", "", rownames(asv_counts))
print(richEven)
```

Convert the raw counts to relative abundance and display plots of the relative quantity of each ASV. Note

```{r}
#| include: false
# Get total counts and calculate relative abundance
row_total_counts <- rowSums(asv_counts)
asv_rel_abundance <- asv_counts / row_total_counts

# Convert matrix to data frame and keep rownames
asv_df <- as.data.frame(asv_rel_abundance)
asv_df$Sample <- gsub("_F_filt.fastq.gz$", "", rownames(asv_df))

# Pivot to long format
asv_long <- pivot_longer(asv_df, 
                         cols = -Sample,
                         names_to = "ASV", 
                         values_to = "RelativeAbundance")

# Add a psuedocount of 10^-6 if plotting in logscale
# asv_long$RelativeAbundance <- asv_long$RelativeAbundance + 1e-6

asv_long[order(asv_long$Sample),]

asv_long$P_Sample <- sub("-.*", "", asv_long$Sample)
```

If there are many ASVs we might want to cluster. This code block clusters based on pairwise distances using the DECIPHER distancematrix. The linkage criteria and height difference to use can be set as the parameters below. The taxa associated with the most abundant ASV for each cluster can also be included in the label.This block generates one combined figure for all samples.

```{r}
linkage <- "complete" #c("single", "average", "complete", "ward.D2")
similarity <- 0.01#c(0.005, 0.01, 0.03)
filter_level <- 0.0005

# Load taxa-file
taxa_df <- read.csv(paste0(folder_path, "/taxa_files/blast_top_hit_compact.tsv"), sep = "\t", header = TRUE)
taxa_df$taxa <- sub(".*s:", "", taxa_df$taxa)

# Before running the loop filter the data
filtered_set <- asv_long %>%
  group_by(ASV, P_Sample) %>%
  mutate(p_sample_proportion = sum(RelativeAbundance)/length(unique(Sample))) %>%
  ungroup() %>%
  filter(p_sample_proportion > filter_level) %>%
  group_by(Sample) %>%
  mutate(RelativeAbundance = RelativeAbundance/sum(RelativeAbundance)) %>%
  ungroup()

# Rebuild the clusters
asv_seqs <- asv_map %>%
  distinct(ASV_ID, Sequence)
seq_set <- DNAStringSet(asv_seqs$Sequence)
names(seq_set) <- asv_seqs$ASV           # preserve ASV IDs
dm <- DistanceMatrix(seq_set, type = "dist")  # fast C implementation

hc <- hclust(dm, method = linkage)
cl_vec <- cutree(hc, h = similarity)  

## Map the ASVs → ClusterID
asv2clust <- tibble(
  ASV        = names(seq_set),
  ClusterID  = paste0("CL", cl_vec)    # convert integer to string label
)
top_taxa <- filtered_set %>%
  group_by(ASV) %>%
  summarise(Abund = sum(RelativeAbundance), .groups = "drop") %>%
  left_join(asv2clust, by = "ASV") %>%
  left_join(taxa_df,  by = c("ASV" = "query")) %>%
  group_by(ClusterID) %>%
  slice_max(Abund, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(Label = sprintf("%s — %s", ClusterID, taxa)) %>%
  select(ClusterID, Label)

# Df with ASV, cluster and taxa on ASV level
ASV_taxa_cluster_df <- taxa_df %>% 
  left_join(asv2clust, by = c("query" = "ASV"))

cluster_levels <- top_taxa$Label
n_clusters     <- length(cluster_levels)
# Colors using polychrome
set.seed(0)
anchor_pastel <- c("#FF0000", "#00FF00", "#0000FF")
main_colors <- createPalette(n_clusters, anchor_pastel)

pastelise <- function(cols, desat = 0.6, lighten = 0.3) {
  cols %>%
    desaturate(amount = desat) %>%   # pull chroma toward grey
    lighten  (amount = lighten)      # push luminance up toward white
}
main_colors <- pastelise(main_colors)
final_palette <- c("Other" = "grey70", main_colors)
names(final_palette) <- c("Other", cluster_levels)
  
cluster_df <- filtered_set %>%                  # Sample | ASV | RelativeAbundance
    left_join(asv2clust, by = "ASV") %>%      # Add ClusterID
    left_join(top_taxa,   by = "ClusterID") %>%
    add_count(ClusterID, wt = RelativeAbundance, name = "total_cluster_abundance") %>%
    mutate(
      Label = fct_lump_n(
        Label, n = 50,
        w = total_cluster_abundance,
        other_level = "Other"
      )
    ) %>%
    group_by(Sample, Label) %>%
    summarise(ClustRelAbundance = sum(RelativeAbundance), .groups = "drop") %>%
    add_count(Label, wt = ClustRelAbundance,
              name = "total_abundance_final") %>%
    mutate(Label = fct_reorder(Label, total_abundance_final),
           Label = fct_relevel(Label, "Other", after = 0)) %>%
    ungroup()

# Titles and stuff
title_txt <- sprintf("Community composition — top %s clusters", min(50, length(unique(cluster_df$Label))))
subtitle_txt <- glue(
"{str_to_title(linkage)} linkage at {percent(similarity, accuracy = 0.01)}",
"→ {comma(n_clusters)} clusters from {length(unique(filtered_set$ASV))} ASVs \n Removed ASVs with sample abundance <{percent(filter_level, accuracy = 0.01)}"
)

caption_txt <- if (length(unique(cluster_df$Label)) > 50) 
  {"Clusters not in top 50 are grouped as “Other”."} else {""}

ggplot(cluster_df, aes(x = Sample, y = ClustRelAbundance, fill = Label)) +
  geom_bar(stat = "identity", color = "grey30", linewidth = 0.2) +
  scale_y_continuous(name = "Relative Abundance",
    labels = scales::percent_format(),
    expand = c(0, 0) # Remove padding at the bottom of the bars
   ) +
  scale_fill_manual(name = "Cluster (top-hit species)", values = final_palette) +
  guides(fill = guide_legend(
   override.aes = list(size = 3),   # icon / key size
   ncol = 2 
  )) +
  labs(x = "Sample", title = title_txt, 
       subtitle = subtitle_txt, caption = caption_txt) +
  theme_minimal(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5),
    legend.text = element_text(size = 5),
    legend.title = element_text(size = 10, face = "bold"),
    legend.key.size = unit(2, "mm"),                 # width & height
    legend.spacing.y = unit(1, "mm"),                # reduce spacing between keys
    legend.position = "right"
  ) 
ggsave(sprintf(paste0(folder_path, "figures/Combined-all-samples-%s-%s-filter-%s.pdf"), linkage, similarity, filter_level), width = 12, height = 5)
```

Another way to cluster the ASVs apart from the PID is to do map each ASV to a taxa and then cluster on a taxonomic level. Below is an implementation to cluster ASVs on a species or genus level. But first generate the color palette for all samples to analyze

```{r}
cluster_taxa_level <- "s" # s or g or f
# Load taxa-file
samples_to_color <- c("phe", "nap", "none")
taxa_df <- data.frame()
for (sample_path in samples_to_color) {
  taxa_df <- taxa_df %>%
    bind_rows(read.csv(paste0("../../results/ngs/", sample_path, "/taxa_files/blast_top_hit_compact.tsv"), sep = "\t", header = TRUE))
}

taxa_df <- taxa_df %>%
  mutate(
    g = sub(",s:.*", "", sub(".*g:", "", taxa)),
    s = paste(g, sub("^.* ", "", sub(".*s:", "", taxa))),
    f = sub(",g:.*", "", sub(".*f:", "", taxa)),
    o = sub(",f:.*", "", sub(".*o:", "", taxa)),
    c = sub(",o:.*", "", sub(".*c:", "", taxa)),
    p = sub(",c:.*", "", sub(".*p:", "", taxa))
  )

cluster_levels <- as.character(unique(taxa_df[[cluster_taxa_level]]))
n_clusters     <- length(cluster_levels)
# Colors using polychrome
set.seed(0)
anchor_pastel <- c("#FF0000", "#00FF00", "#0000FF")
main_colors <- createPalette(n_clusters, anchor_pastel)

pastelise <- function(cols, desat = 0.6, lighten = 0.3) {
  cols %>%
    desaturate(amount = desat) %>%   # pull chroma toward grey
    lighten  (amount = lighten)      # push luminance up toward white
}
main_colors <- pastelise(main_colors)
final_palette <- c("Other" = "grey70", main_colors)
names(final_palette) <- c("Other", cluster_levels)
```

```{r}
filter_level <- 0
# Load taxa-file
taxa_df <- read.csv(paste0(folder_path, "/taxa_files/blast_top_hit_compact.tsv"), sep = "\t", header = TRUE)

taxa_df <- taxa_df %>%
  mutate(
    g = sub(",s:.*", "", sub(".*g:", "", taxa)),
    s = paste(g, sub("^.* ", "", sub(".*s:", "", taxa))),
    f = sub(",g:.*", "", sub(".*f:", "", taxa)),
    o = sub(",f:.*", "", sub(".*o:", "", taxa)),
    c = sub(",o:.*", "", sub(".*c:", "", taxa)),
    p = sub(",c:.*", "", sub(".*p:", "", taxa))
  )

# Before running the loop filter the data
filtered_set <- asv_long %>%
  group_by(ASV, P_Sample) %>%
  mutate(p_sample_proportion = sum(RelativeAbundance)/length(unique(Sample))) %>%
  ungroup() %>%
  filter(p_sample_proportion > filter_level) %>%
  group_by(Sample) %>%
  mutate(RelativeAbundance = RelativeAbundance/sum(RelativeAbundance)) %>%
  ungroup()

# Now add the taxa
asv2clust <- taxa_df %>% 
  dplyr::rename(ASV = query) %>%
  mutate(Label = .data[[cluster_taxa_level]]) %>%
  select(ASV, {{ cluster_taxa_level }}, Label)

# Get the most abundant ASV from each cluster
filtered_taxa_df <- taxa_df %>% 
  dplyr::rename(ASV = query) %>%
  left_join(filtered_set, by = "ASV") %>%
  group_by(Sample, s) %>%
  mutate(ClustRelAbundance = sum(RelativeAbundance)) %>%
  add_count(s, wt = ClustRelAbundance, name = "total_abundance_final") %>%
  ungroup() %>%
  select(ASV, s, total_abundance_final) %>%
  left_join(asv_map, by = c("ASV" = "ASV_ID")) %>%
  group_by(s) %>% 
  filter(total_abundance_final > filter_level) %>%
  slice_max(total_abundance_final, n = 1, with_ties = FALSE) %>%
  ungroup()

# Save the top ASV for each taxa cluster in a fasta file
dna <- DNAStringSet(filtered_taxa_df$Sequence) 
names(dna) <- sprintf("%s", filtered_taxa_df$ASV)
writeXStringSet(dna, filepath = paste0(folder_path, "/top_ASVs_per_taxa.fasta"), format   = "fasta")

cluster_df <- filtered_set %>%                  # Sample | ASV | RelativeAbundance
    left_join(asv2clust, by = "ASV") %>%      # Add Cluster
    add_count(Label, wt = RelativeAbundance, name = "total_cluster_abundance") %>%
    mutate(
      Label = fct_lump_n(
        Label, n = 50,
        w = total_cluster_abundance,
        other_level = "Other"
      )
    ) %>%
    group_by(Sample, Label) %>%
    summarise(ClustRelAbundance = sum(RelativeAbundance), .groups = "drop") %>%
    add_count(Label, wt = ClustRelAbundance,
              name = "total_abundance_final") %>%
    mutate(Label = fct_reorder(Label, total_abundance_final),
           Label = fct_relevel(Label, "Other", after = 0)) %>%
    ungroup()

cluster_levels <- as.character(unique(asv2clust$Label))
n_clusters     <- length(cluster_levels)
  
# Titles and stuff
title_txt <- sprintf("Community composition — top %s clusters", min(50, length(unique(cluster_df$Label))))
subtitle_txt <- glue("{n_clusters} clusters from {length(unique(filtered_set$ASV))} ASVs"
)
caption_txt <- if (length(unique(cluster_df$Label)) > 50) 
  {"Clusters not in top 50 are grouped as “Other”."} else {""}

ggplot(cluster_df, aes(x = Sample, y = ClustRelAbundance, fill = Label)) +
  geom_bar(stat = "identity", color = "grey30", linewidth = 0.2) +
  scale_y_continuous(name = "Relative Abundance",
    labels = scales::percent_format(),
    expand = c(0, 0) # Remove padding at the bottom of the bars
   ) +
  scale_fill_manual(name = sprintf("Species cluster (top-hit species)"), values = final_palette) +
  guides(fill = guide_legend(
   override.aes = list(size = 3),   # icon / key size
   ncol = 2 
  )) +
  labs(x = "Sample", title = title_txt, 
       subtitle = subtitle_txt, caption = caption_txt) +
  theme_minimal(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5),
    legend.text = element_text(size = 5),
    legend.title = element_text(size = 10, face = "bold"),
    legend.key.size = unit(2, "mm"),                 # width & height
    legend.spacing.y = unit(1, "mm"),                # reduce spacing between keys
    legend.position = "right"
  ) 
ggsave(sprintf(paste0(folder_path, "figures/", process_sample, "-Combined-all-samples-taxa-cluster-%s-filter-%s.pdf"), cluster_taxa_level, filter_level), width = 12, height = 5)

```

Look into the Sphingobium genus or other genus, showing how the ASVs change in abundance, deep dive into each cluster.

```{r}
filter_ASV <- "Sphingobium czechense" # Sphingomonadaceae Sphingobium czechense
filter_level <- 0

taxa_of_interest <- taxa_df %>%
  filter(s == filter_ASV)

# Now add the taxa
asv2clust <- taxa_df %>% 
  rename(ASV = query) %>%
  mutate(Label = s) %>%
  select(ASV, s, Label)

filtered_set <- asv_long %>%
  group_by(ASV, P_Sample) %>%
  mutate(p_sample_proportion = sum(RelativeAbundance)/length(unique(Sample))) %>%
  ungroup() %>%
  filter(p_sample_proportion > filter_level) %>%
  group_by(Sample) %>%
  mutate(RelativeAbundance = RelativeAbundance/sum(RelativeAbundance)) %>%
  ungroup()

ASV_plot_data <- filtered_set %>%
  filter(ASV %in% taxa_of_interest$query) %>%
  left_join(asv2clust, by = "ASV") %>%
  mutate(
    Label = paste(ASV, "-", Label)
  ) %>%
  group_by(Sample, Label) %>%
  summarise(ClustRelAbundance = sum(RelativeAbundance), .groups = "drop") %>%
  add_count(Label, wt = ClustRelAbundance,
            name = "total_abundance_final") %>%
  mutate(Label = fct_reorder(Label, total_abundance_final)) %>%
  ungroup()

# # Colors using polychrome
pastelise <- function(cluster_levels, desat = 0.6, lighten = 0.3) {
  n_clusters     <- length(cluster_levels)
  set.seed(0)
  anchor_pastel <- c("#FF0000", "#00FF00", "#0000FF")
  cols <- createPalette(n_clusters, anchor_pastel)
  cols %>%
    desaturate(amount = desat) %>%   # pull chroma toward grey
    lighten  (amount = lighten)      # push luminance up toward white
}

cluster_levels <- as.character(unique(ASV_plot_data$Label))
final_palette <- pastelise(cluster_levels)
names(final_palette) <- c(cluster_levels)

# Titles and stuff
title_txt <- sprintf("Community composition — ASVs in species %s", filter_ASV)
subtitle_txt <- glue("{length(cluster_levels)} ASVs, filtered at {percent(filter_level, accuracy = 0.01)}")
caption_txt <- if (length(unique(cluster_df$Label)) > 50) 
  {"Relative abundances calculated from the entire community"} else {""}

ggplot(ASV_plot_data, aes(x = Sample, y = ClustRelAbundance, fill = Label)) +
  geom_bar(stat = "identity", color = "grey30", linewidth = 0.2) +
  scale_y_continuous(name = "Relative Abundance",
    labels = scales::percent_format(),
    expand = c(0, 0) # Remove padding at the bottom of the bars
   ) +
  scale_fill_manual(name = "ASV - Species", values = final_palette) +
  guides(fill = guide_legend(
   override.aes = list(size = 3),   # icon / key size
   ncol = 2
  )) +
  labs(x = "Sample", title = title_txt, 
       subtitle = subtitle_txt, caption = caption_txt) +
  theme_minimal(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5),
    legend.text = element_text(size = 5),
    legend.title = element_text(size = 10, face = "bold"),
    legend.key.size = unit(2, "mm"),                 # width & height
    legend.spacing.y = unit(1, "mm"),                # reduce spacing between keys
    legend.position = "right"
  )

ggsave(sprintf(paste0(folder_path, "figures/%s-only-none-complete-ASVs-filter-%s.pdf"), filter_ASV, filter_level), width = 12, height = 5)
```

Investigate which ASVs or Clusters that have changed substantially in the abundance over the sampling times.

```{r}
library(dplyr)
library(stringr)

cl_long <- cluster_df %>%                       
  mutate(
    Replicate = str_extract(Sample, "P[123]"),      # P1 / P2 / P3
    DataPoint       = as.numeric(str_extract(Sample, "\\d+$"))   # 00-28 → 0-28
  )

cl_long <- cl_long %>%
  group_by(Replicate) %>%
  mutate(threshold_day = 14) %>%      # ceiling(0.70 * max(DataPoint) each run’s x % or just 14 
  ungroup()

fold_tbl <- cl_long %>%
  group_by(Replicate, Label) %>%
  summarise(
    point0_abund  = sum(ClustRelAbundance[DataPoint == 0]),
    late_abund  = max(ClustRelAbundance[DataPoint >= unique(threshold_day)]),
    fold_change = round(late_abund / (point0_abund), 2),
    .groups = "drop"
  )

clusters_big_jump <- fold_tbl %>%
  filter(fold_change >= 5) %>%      # avoid div/0 artefacts
  distinct(Label, .keep_all = TRUE)                                   # one row per cluster

plotting_clusters_df <- cluster_df %>%
  filter(Label %in% clusters_big_jump$Label)

asv2clust_big_jump <- asv2clust %>%
  filter(Label %in% clusters_big_jump$Label)

cluster_levels <- as.character(unique(asv2clust_big_jump$Label))
n_clusters     <- length(cluster_levels)
# Colors using polychrome
set.seed(0)
anchor_pastel <- c("#FF0000", "#00FF00", "#0000FF")
main_colors <- createPalette(n_clusters, anchor_pastel)

pastelise <- function(cols, desat = 0.6, lighten = 0.3) {
  cols %>%
    desaturate(amount = desat) %>%   # pull chroma toward grey
    lighten  (amount = lighten)      # push luminance up toward white
}
main_colors <- pastelise(main_colors)
final_palette <- c("Other" = "grey70", main_colors)
names(final_palette) <- c("Other", cluster_levels)
  

ggplot(plotting_clusters_df, aes(x = Sample, y = ClustRelAbundance, fill = Label)) +
  geom_bar(stat = "identity", color = "grey30", linewidth = 0.2) +
  scale_y_continuous(name = "Relative Abundance",
    labels = scales::percent_format(),
    expand = c(0, 0) # Remove padding at the bottom of the bars
   ) +
  scale_fill_manual(name = "Cluster (top-hit species)", values = final_palette) +
  guides(fill = guide_legend(
   override.aes = list(size = 3),   # icon / key size
   ncol = 2 
  )) +
  labs(x = "Sample", title = title_txt, 
       subtitle = subtitle_txt, caption = caption_txt) +
  theme_minimal(base_size = 10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5),
    legend.text = element_text(size = 5),
    legend.title = element_text(size = 10, face = "bold"),
    legend.key.size = unit(2, "mm"),                 # width & height
    legend.spacing.y = unit(1, "mm"),                # reduce spacing between keys
    legend.position = "right"
  ) 


```
